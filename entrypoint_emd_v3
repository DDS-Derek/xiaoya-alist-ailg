#!/bin/sh

Green="\033[32m"
Red="\033[31m"
Yellow='\033[33m'
Font="\033[0m"
INFO="[${Green}INFO${Font}]"
ERROR="[${Red}ERROR${Font}]"
WARN="[${Yellow}WARN${Font}]"

DEFAULT_ARGS="--local-media /media --report --localdb /media"

INFO() {
    echo -e "${INFO} ${1}"
}

ERROR() {
    echo -e "${ERROR} ${1}"
}

WARN() {
    echo -e "${WARN} ${1}"
}


update_loop_files() {
    local img_type="$1"
    local loop_device="$2"
    local img_path="$3"
    
    local temp_file=$(mktemp)
    local updated=false
    
    if [ -f "/ailg/.loop" ]; then
        while IFS= read -r line; do
            if [[ "$line" =~ ^$img_type\  ]]; then
                local original_path=$(echo "$line" | awk '{print $3}')
                echo "$img_type $loop_device $original_path" >> "$temp_file"
                updated=true
            else
                echo "$line" >> "$temp_file"
            fi
        done < "/ailg/.loop"
    fi
    
    if [ "$updated" = false ]; then
        echo "$img_type $loop_device $img_path" >> "$temp_file"
    fi
    
    mv "$temp_file" "/ailg/.loop"
    
    INFO "已更新.loop文件: $img_type -> $loop_device" >&2
}

cleanup_container_loops() {
    INFO "开始清理容器内无效的loop设备绑定..." >&2
    
    local protected_loops=""
    if [ -f "/ailg/.loop" ]; then
        local media_loop=$(grep "^media " "/ailg/.loop" 2>/dev/null | awk '{print $2}')
        local config_loop=$(grep "^config " "/ailg/.loop" 2>/dev/null | awk '{print $2}')
        
        if [ -n "$media_loop" ]; then
            protected_loops="$protected_loops $media_loop"
            INFO "保护media loop设备: $media_loop" >&2
        fi
        if [ -n "$config_loop" ]; then
            protected_loops="$protected_loops $config_loop"
            INFO "保护config loop设备: $config_loop" >&2
        fi
    fi
    
    local loop_devices=$(losetup -a 2>/dev/null)
    if [ -z "$loop_devices" ]; then
        INFO "未发现需要清理的无效loop设备" >&2
        return 0
    fi
    
    local cleanup_count=0
    echo "$loop_devices" | while IFS= read -r line; do
        if [ -z "$line" ]; then
            continue
        fi
        
        local loop_device=$(echo "$line" | cut -d: -f1)
        if [ -z "$loop_device" ]; then
            continue
        fi
        
        local is_protected=false
        for protected_loop in $protected_loops; do
            if [ "$loop_device" = "$protected_loop" ]; then
                is_protected=true
                break
            fi
        done
        
        if [ "$is_protected" = true ]; then
            INFO "跳过受保护的loop设备: $loop_device" >&2
            continue
        fi
        
        local bound_file=""
        if echo "$line" | grep -q "("; then
            bound_file=$(echo "$line" | sed 's/.*(\([^)]*\)).*/\1/')
        else
            bound_file=$(echo "$line" | awk '{print $NF}')
        fi
        
        local should_cleanup=false
        if [ "$bound_file" = "/" ]; then
            should_cleanup=true
        elif [[ "$bound_file" =~ ^/.*\.img$ ]] && [[ "$bound_file" != "/config.img" ]] && [[ "$bound_file" != "/media.img" ]] && [[ "$bound_file" != "/media_jf.img" ]]; then
            should_cleanup=true
        fi
        
        if [ "$should_cleanup" = true ]; then
            INFO "发现无效loop设备绑定: $loop_device -> $bound_file，开始清理..." >&2
            
            if umount -l "$loop_device" 2>/dev/null; then
                INFO "成功卸载: $loop_device" >&2
            else
                WARN "卸载失败: $loop_device" >&2
            fi
            
            if losetup -d "$loop_device" 2>/dev/null; then
                INFO "成功解除loop设备绑定: $loop_device" >&2
                cleanup_count=$((cleanup_count + 1))
                
                if ! losetup -a | grep -q "^$loop_device:"; then
                    INFO "确认loop设备已完全解除绑定: $loop_device" >&2
                else
                    WARN "losetup -d可能未完全成功: $loop_device" >&2
                fi
            else
                WARN "解除loop设备绑定失败: $loop_device" >&2
            fi
        fi
    done
    
    if [ $cleanup_count -gt 0 ]; then
        INFO "清理完成，共处理了 $cleanup_count 个无效loop设备" >&2
    else
        INFO "未发现需要清理的无效loop设备" >&2
    fi
}

get_loop_device() {
    local img_file="$1"
    local offset="${2:-10000000}"
    
    local mount_dir
    local state_file_dir
    if [ "$img_file" = "media.img" ] || [ "$img_file" = "media_jf.img" ]; then
        mount_dir="/volume_img"
        if [ -f "/ailg/.loop" ]; then
            state_file_dir="/ailg"
        else
            state_file_dir="/volume_img/xiaoya"
        fi
    else
        return 1
    fi
    
    local loop_device=""
    if [ -f "$state_file_dir/.loop" ]; then
        loop_device=$(grep "^media " "$state_file_dir/.loop" | awk '{print $2}')
        
        if [ -n "$loop_device" ]; then
            INFO "从$state_file_dir/.loop获取到loop设备: $loop_device" >&2
        else
            INFO "未在$state_file_dir/.loop中找到对应的loop设备" >&2
        fi
        
        if [ -n "$loop_device" ]; then
            local existing_binding=""
            if losetup -a | grep -q "("; then
                existing_binding=$(losetup -a | grep "($img_file)")
            else
                existing_binding=$(losetup -a | grep "/$img_file")
            fi
            
            local loop_device_binding=$(losetup -a | grep "^$loop_device:")
            
            if [ -n "$existing_binding" ]; then
                local existing_loop=$(echo "$existing_binding" | cut -d: -f1)
                INFO "发现已有loop绑定: $existing_loop -> /$img_file" >&2
                
                if [ "$existing_loop" = "$loop_device" ]; then
                    INFO "loop设备号一致，视为已经绑定" >&2
                    if mount "$loop_device" "$mount_dir" 2>/dev/null; then
                        local recorded_path=$(grep "^media " "$state_file_dir/.loop" | awk '{print $3}')
                        local current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
                        
                        # 处理current_path：如果以@开头，去掉第一节路径
                        if [[ "$current_path" =~ ^/@ ]]; then
                            current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
                        fi
                        
                        local recorded_filename=$(basename "$recorded_path")
                        local current_filename=$(basename "$current_path")
                        
                        if [ "$recorded_filename" = "$current_filename" ] || 
                           [[ "$recorded_path" == *"$current_filename" ]] || 
                           [[ "$current_path" == *"$recorded_filename" ]]; then
                            INFO "挂载路径一致，操作成功" >&2
                            return 0
                        else
                            INFO "挂载路径不一致，需要重新绑定" >&2
                            umount -l "$loop_device" 2>/dev/null
                            losetup -d "$loop_device" 2>/dev/null
                        fi
                    else
                        INFO "挂载失败，需要重新绑定" >&2
                    fi
                else
                    INFO "loop设备号不一致，更新.loop文件并重新绑定" >&2
                    umount -l "$existing_loop" 2>/dev/null
                    losetup -d "$existing_loop" 2>/dev/null
                fi
            elif [ -n "$loop_device_binding" ]; then
                # 指定的loop_device已经被绑定到其他文件，先尝试直接挂载检查是否为同一镜像
                INFO "loop设备 $loop_device 已被绑定到其他文件，尝试直接挂载检查" >&2
                if mount "$loop_device" "$mount_dir" 2>/dev/null; then
                    # 检查/proc/self/mountinfo中的路径是否与.loop一致
                    local recorded_path=$(grep "^media " "$state_file_dir/.loop" | awk '{print $3}')
                    local current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
                    
                    # 处理current_path：如果以@开头，去掉第一节路径
                    if [[ "$current_path" =~ ^/@ ]]; then
                        current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
                    fi
                    
                    # 路径比较：检查两个路径是否指向同一个文件
                    local recorded_filename=$(basename "$recorded_path")
                    local current_filename=$(basename "$current_path")
                    
                    if [ "$recorded_filename" = "$current_filename" ] || 
                       [[ "$recorded_path" == *"$current_filename" ]] || 
                       [[ "$current_path" == *"$recorded_filename" ]]; then
                        INFO "挂载路径一致，操作成功" >&2
                        return 0
                    else
                        INFO "挂载路径不一致，需要重新绑定" >&2
                        umount -l "$loop_device" 2>/dev/null
                        losetup -d "$loop_device" 2>/dev/null
                        # 验证losetup -d是否成功
                        if ! losetup -a | grep -q "^$loop_device:"; then
                            INFO "成功解除loop设备绑定: $loop_device" >&2
                        else
                            WARN "losetup -d可能未完全成功，但继续尝试重新绑定" >&2
                        fi
                    fi
                else
                    INFO "挂载失败，需要解除绑定后重新绑定" >&2
                    umount -l "$loop_device" 2>/dev/null
                    losetup -d "$loop_device" 2>/dev/null
                    # 验证losetup -d是否成功
                    if ! losetup -a | grep -q "^$loop_device:"; then
                        INFO "成功解除loop设备绑定: $loop_device" >&2
                    else
                        WARN "losetup -d可能未完全成功，但继续尝试重新绑定" >&2
                    fi
                fi
            else
                INFO "容器中无/$img_file相关的loop绑定，使用.loop中的设备号" >&2
            fi
            
            if losetup -o "$offset" "$loop_device" "/$img_file"; then
                if mount "$loop_device" "$mount_dir"; then
                    local current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
                    
                    # 处理current_path：如果以@开头，去掉第一节路径
                    if [[ "$current_path" =~ ^/@ ]]; then
                        current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
                    fi
                    
                    local img_type="media"
                    
                    update_loop_files "$img_type" "$loop_device" "$current_path"
                    INFO "成功绑定并挂载: $loop_device -> /$img_file" >&2
                    return 0
                else
                    losetup -d "$loop_device"
                    return 1
                fi
            else
                ERROR "绑定loop设备失败: $loop_device -> /$img_file"
                return 1
            fi
        fi
    fi
    
    INFO "未找到$state_file_dir/.loop文件，获取新的loop设备" >&2
    new_loop=$(losetup -f)
    
    if [ -n "$new_loop" ] && [ ! -e "$new_loop" ]; then
        loop_num=$(echo "$new_loop" | grep -o '[0-9]\+$')
        if ! mknod "$new_loop" b 7 "$loop_num" 2>/dev/null; then
            return 1
        fi
    elif [ -z "$new_loop" ]; then
        return 1
    fi
    
    if losetup -o "$offset" "$new_loop" "/$img_file"; then
        if mount "$new_loop" "$mount_dir"; then
            mkdir -p "/ailg"
            current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
            
            # 处理current_path：如果以@开头，去掉第一节路径
            if [[ "$current_path" =~ ^/@ ]]; then
                current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
            fi
            
            local img_type="media"
            
            update_loop_files "$img_type" "$new_loop" "$current_path"
            INFO "成功绑定并挂载新设备: $new_loop -> /$img_file" >&2
            return 0
        else
            losetup -d "$new_loop"
            rm -f "$new_loop" 2>/dev/null
            return 1
        fi
    else
        losetup -d "$new_loop" 2>/dev/null
        rm -f "$new_loop" 2>/dev/null
        return 1
    fi
}

mount_img() {
    local img_file
    if [ "$MODE" = "jellyfin" ]; then
        img_file="media_jf.img"
    else
        img_file="media.img"
    fi
    
    if [ ! -d /volume_img ]; then
        mkdir -p /volume_img
    fi
    
    if [ -d /media ]; then
        if [ ! -d "/media/电影/豆瓣 top 1000部" ]; then
            if ! rm -rf /media; then
                ERROR '删除 /media 失败！使用老G速装版emby请勿将任何目录挂载到容器的 /media 目录！程序退出！'
                exit 1
            fi
        else
            ERROR '/media 文件夹不为空！使用老G速装版emby请勿将任何目录挂载到容器的 /media 目录！程序退出！'
            exit 1
        fi
    fi
    
    cleanup_container_loops
    
    if ! get_loop_device "$img_file"; then
        ERROR "$img_file loop设备绑定或挂载失败，程序退出！"
        exit 1
    fi
    
    INFO "媒体库img镜像挂载成功！"
    
    ln -sf /volume_img/xiaoya /media
    if [ -L "/volume_img/xiaoya/xiaoya" ]; then
        rm -f "/volume_img/xiaoya/xiaoya"
    fi
    INFO "/media 创建软链接成功！"
}

MODE=${MODE:-emby}

if [ "$MODE" = "jellyfin" ]; then
    img_file="/media_jf.img"
else
    img_file="/media.img"
fi

if [ -f "$img_file" ]; then
    mount_img
fi

if [ ! -f /bin/user/sync_xy ]; then
    ERROR "sync_xy程序不存在，退出！"
    exit 1
fi

CYCLE=${CYCLE:-24}

has_local_media=0
has_report=0
has_localdb=0

for arg in "$@"; do
    case "$arg" in
        --local-media)
            has_local_media=1
            ;;
        --report)
            has_report=1
            ;;
        --localdb)
            has_localdb=1
            ;;
    esac
done

FINAL_ARGS=""

if [ $# -eq 0 ]; then
    FINAL_ARGS="$DEFAULT_ARGS"
else
    FINAL_ARGS="$@"
    if [ $has_local_media -eq 0 ]; then
        FINAL_ARGS="$FINAL_ARGS --local-media /media"
    fi
    if [ $has_report -eq 0 ]; then
        FINAL_ARGS="$FINAL_ARGS --report"
    fi
    if [ $has_localdb -eq 0 ]; then
        FINAL_ARGS="$FINAL_ARGS --localdb /media"
    fi
fi

if [ "${CYCLE}" -lt 12 ]; then
    WARN "您设置的循环时间小于12h，对于服务器压力过大，同步下载将不会运行！"
    tail -f /dev/null
else
    while true; do
        /bin/user/sync_xy $FINAL_ARGS
        
        TOTAL_SECONDS=$((CYCLE * 3600))
        START_TIME=$(date +%s)
        END_TIME=$((START_TIME + TOTAL_SECONDS))

        if [ -f /xy_sync_ver.txt ]; then
            VERSION=$(cat /xy_sync_ver.txt)
            INFO "当前G-BOX小雅Emby同步工具版本：${VERSION}"
        fi
        
        INFO "当前同步周期为${CYCLE}小时，开始倒计时..."
        
        LOG_INTERVAL=3600
        NEXT_LOG_TIME=$(($(date +%s) + LOG_INTERVAL))
        
        while [ $(date +%s) -lt $END_TIME ]; do
            NOW=$(date +%s)
            REMAINING=$((END_TIME - NOW))
            
            NEXT_EVENT_TIME=$END_TIME
            if [ $NEXT_LOG_TIME -lt $NEXT_EVENT_TIME ]; then
                NEXT_EVENT_TIME=$NEXT_LOG_TIME
            fi
            
            WAIT_TIME=$((NEXT_EVENT_TIME - NOW))
            if [ $WAIT_TIME -lt 1 ]; then
                WAIT_TIME=1
            fi
            
            sleep $WAIT_TIME
            
            NOW=$(date +%s)
            if [ $NOW -ge $NEXT_LOG_TIME ]; then
                REMAINING=$((END_TIME - NOW))
                HOURS=$((REMAINING / 3600))
                MINUTES=$(( (REMAINING % 3600) / 60 ))
                SECONDS=$((REMAINING % 60))
                INFO "距离下次同步还剩: ${HOURS}小时${MINUTES}分钟${SECONDS}秒"
                NEXT_LOG_TIME=$((NOW + LOG_INTERVAL))
            fi
        done
    done
fi
