#!/usr/bin/with-contenv sh
# shellcheck shell=sh
# shellcheck disable=SC2114

# 日志函数
INFO() {
    echo "[INFO] $*"
}

WARN() {
    echo "[WARN] $*"
}

ERROR() {
    echo "[ERROR] $*"
}

# 检测并同步.loop文件到/ailg_config
sync_loop_files() {
    # 检查是否存在/ailg_config目录
    if [ -d "/ailg_config" ]; then
        # 检查/ailg_config中是否有emby-config开头的img文件
        if ls /ailg_config/emby-config*.img >/dev/null 2>&1 || ls /ailg_config/jellyfin-config*.img >/dev/null 2>&1; then
            INFO "检测到/ailg_config目录中有config镜像文件，开始同步.loop文件" >&2
            
            # 如果/ailg/.loop存在，将其复制到/ailg_config/.loop
            if [ -f "/ailg/.loop" ]; then
                cp -f "/ailg/.loop" "/ailg_config/.loop"
                INFO "已将/ailg/.loop同步到/ailg_config/.loop" >&2
            else
                INFO "/ailg/.loop不存在，无需同步" >&2
            fi
        else
            INFO "/ailg_config目录存在但无config镜像文件，跳过同步" >&2
        fi
    else
        INFO "未检测到/ailg_config目录，使用标准.loop文件管理" >&2
    fi
}

# 在脚本开始时同步.loop文件
sync_loop_files

# 更新.loop文件到所有相关位置
update_loop_files() {
    local img_type="$1"
    local loop_device="$2"
    local img_path="$3"
    
    # 更新/ailg/.loop
    local temp_file=$(mktemp)
    local updated=false
    
    if [ -f "/ailg/.loop" ]; then
        while IFS= read -r line; do
            if [[ "$line" =~ ^$img_type\  ]]; then
                # 更新现有行，保持原有的完整路径格式
                local original_path=$(echo "$line" | awk '{print $3}')
                echo "$img_type $loop_device $original_path" >> "$temp_file"
                updated=true
            else
                # 保留其他行
                echo "$line" >> "$temp_file"
            fi
        done < "/ailg/.loop"
    fi
    
    # 如果没有找到对应类型的行，添加新行
    if [ "$updated" = false ]; then
        echo "$img_type $loop_device $img_path" >> "$temp_file"
    fi
    
    # 替换原文件
    mv "$temp_file" "/ailg/.loop"
    
    # 如果存在/ailg_config目录，也更新/ailg_config/.loop
    if [ -d "/ailg_config" ]; then
        cp -f "/ailg/.loop" "/ailg_config/.loop"
        INFO "已同步.loop文件到/ailg_config/.loop" >&2
    fi
    
    INFO "已更新.loop文件: $img_type -> $loop_device" >&2
}

# loop设备管理函数
get_loop_device() {
    local img_file="$1"
    local offset="${2:-10000000}"
    
    # 根据img文件类型确定挂载目录和状态文件路径
    local mount_dir
    local state_file_dir
    if [ "$img_file" = "media.img" ]; then
        mount_dir="/volume_img"
        state_file_dir="/ailg"
    elif [ "$img_file" = "config.img" ]; then
        mount_dir="/volume_cfg"
        # config镜像优先从/ailg_config/.loop读取，如果不存在则从/ailg/.loop读取
        if [ -f "/ailg_config/.loop" ]; then
            state_file_dir="/ailg_config"
        else
            state_file_dir="/ailg"
        fi
    else
        return 1
    fi
    
    # 检查状态文件是否存在
    local loop_device=""
    if [ -f "$state_file_dir/.loop" ]; then
        # 根据img文件类型从.loop文件解析出对应的loop设备号
        if [ "$img_file" = "media.img" ]; then
            loop_device=$(grep "^media " "$state_file_dir/.loop" | awk '{print $2}')
        elif [ "$img_file" = "config.img" ]; then
            loop_device=$(grep "^config " "$state_file_dir/.loop" | awk '{print $2}')
        fi
        
        
        if [ -n "$loop_device" ]; then
            INFO "从/ailg/.loop获取到loop设备: $loop_device" >&2
        else
            INFO "未在/ailg/.loop中找到对应的loop设备" >&2
        fi
        
        if [ -n "$loop_device" ]; then
            # 检查容器中losetup -a是否有/media.img相关的loop绑定
            local existing_binding=""
            # 处理不同格式的losetup输出
            if losetup -a | grep -q "("; then
                # 宿主机格式: 查找 (/img_file) 格式
                existing_binding=$(losetup -a | grep "($img_file)")
            else
                # 容器内格式: 查找末尾的img_file
                existing_binding=$(losetup -a | grep "/$img_file")
            fi
            # 检查指定的loop_device是否已经被绑定到其他文件
            local loop_device_binding=$(losetup -a | grep "^$loop_device:")
            
            if [ -n "$existing_binding" ]; then
                local existing_loop=$(echo "$existing_binding" | cut -d: -f1)
                INFO "发现已有loop绑定: $existing_loop -> /$img_file" >&2
                
                # 检查绑定的loop号是否与.loop一致
                if [ "$existing_loop" = "$loop_device" ]; then
                    INFO "loop设备号一致，视为已经绑定" >&2
                    # 直接尝试挂载
                    if mount "$loop_device" "$mount_dir" 2>/dev/null; then
                    # 检查/proc/self/mountinfo中的路径是否与.loop一致
                    local recorded_path=$(grep "^$img_type " "/ailg/.loop" | awk '{print $3}')
                    local current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
                    
                    # 处理current_path：如果以@开头，去掉第一节路径
                    if [[ "$current_path" =~ ^/@ ]]; then
                        current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
                    fi
                    
                    # 路径比较：检查两个路径是否指向同一个文件
                    # 使用包含逻辑：如果recorded_path包含current_filename，或者current_path包含recorded_filename
                    local recorded_filename=$(basename "$recorded_path")
                    local current_filename=$(basename "$current_path")
                    
                    if [ "$recorded_filename" = "$current_filename" ] || 
                       [[ "$recorded_path" == *"$current_filename" ]] || 
                       [[ "$current_path" == *"$recorded_filename" ]]; then
                            INFO "挂载路径一致，操作成功" >&2
                            return 0
                        else
                            INFO "挂载路径不一致，需要重新绑定" >&2
                            umount -l "$loop_device" 2>/dev/null
                            losetup -d "$loop_device" 2>/dev/null
                        fi
                    else
                        INFO "挂载失败，需要重新绑定" >&2
                    fi
                else
                    INFO "loop设备号不一致，更新.loop文件并重新绑定" >&2
                    # 卸载当前绑定的loop设备
                    umount -l "$existing_loop" 2>/dev/null
                    losetup -d "$existing_loop" 2>/dev/null
                fi
            elif [ -n "$loop_device_binding" ]; then
                # 指定的loop_device已经被绑定到其他文件，需要先解除绑定
                INFO "loop设备 $loop_device 已被绑定到其他文件，先解除绑定" >&2
                umount -l "$loop_device" 2>/dev/null
                losetup -d "$loop_device" 2>/dev/null
                # 验证losetup -d是否成功
                if ! losetup -a | grep -q "^$loop_device:"; then
                    INFO "成功解除loop设备绑定: $loop_device" >&2
                else
                    WARN "losetup -d可能未完全成功，但继续尝试重新绑定" >&2
                fi
            else
                INFO "容器中无/media.img相关的loop绑定，使用.loop中的设备号" >&2
            fi
            
            # 使用.loop中的loop设备号重新绑定
            if losetup -o "$offset" "$loop_device" "/$img_file"; then
                if mount "$loop_device" "$mount_dir"; then
                    # 更新.loop文件中的路径信息
                    local current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
                    
                    # 处理current_path：如果以@开头，去掉第一节路径
                    if [[ "$current_path" =~ ^/@ ]]; then
                        current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
                    fi
                    
                    local img_type=""
                    if [ "$img_file" = "media.img" ]; then
                        img_type="media"
                    elif [ "$img_file" = "config.img" ]; then
                        img_type="config"
                    fi
                    
                    # 使用新的更新函数
                    update_loop_files "$img_type" "$loop_device" "$current_path"
                    INFO "成功绑定并挂载: $loop_device -> /$img_file" >&2
                    return 0
                else
                    losetup -d "$loop_device"
                    return 1
                fi
            else
                ERROR "绑定loop设备失败: $loop_device -> /$img_file"
                return 1
            fi
        fi
    fi
    
    # 如果没有.loop文件，直接获取新的loop设备
    INFO "未找到/ailg/.loop文件，获取新的loop设备" >&2
    new_loop=$(losetup -f)
    
    # 检查losetup -f返回的设备是否真实存在
    if [ -n "$new_loop" ] && [ ! -e "$new_loop" ]; then
        # 提取设备号
        loop_num=$(echo "$new_loop" | grep -o '[0-9]\+$')
        if ! mknod "$new_loop" b 7 "$loop_num" 2>/dev/null; then
            return 1
        fi
    elif [ -z "$new_loop" ]; then
        return 1
    fi
    
    # 绑定新的loop设备
    if losetup -o "$offset" "$new_loop" "/$img_file"; then
        if mount "$new_loop" "$mount_dir"; then
            # 挂载成功，记录路径信息到/ailg/.loop
            mkdir -p "/ailg"
            current_path=$(cat /proc/self/mountinfo | grep -o "\/.*\.img /$img_file" | cut -d' ' -f1)
            
            # 处理current_path：如果以@开头，去掉第一节路径
            if [[ "$current_path" =~ ^/@ ]]; then
                current_path=$(echo "$current_path" | sed 's|^/[^/]*||')
            fi
            
            local img_type=""
            if [ "$img_file" = "media.img" ]; then
                img_type="media"
            elif [ "$img_file" = "config.img" ]; then
                img_type="config"
            fi
            
            # 使用新的更新函数
            update_loop_files "$img_type" "$new_loop" "$current_path"
            INFO "成功绑定并挂载新设备: $new_loop -> /$img_file" >&2
            return 0
        else
            losetup -d "$new_loop"
            rm -f "$new_loop" 2>/dev/null
            return 1
        fi
    else
        losetup -d "$new_loop" 2>/dev/null
        rm -f "$new_loop" 2>/dev/null
        return 1
    fi
}

# 清理容器内无效的loop设备绑定
cleanup_container_loops() {
    INFO "开始清理容器内无效的loop设备绑定..." >&2
    
    # 获取所有loop设备信息
    local loop_devices=$(losetup -a)
    local cleaned_count=0
    
    # 解析每个loop设备
    echo "$loop_devices" | while IFS= read -r line; do
        if [ -z "$line" ]; then
            continue
        fi
        
        # 提取loop设备号和绑定路径
        local loop_device=$(echo "$line" | cut -d: -f1)
        local back_file=""
        
        # 处理不同格式的losetup输出
        # 宿主机格式: /dev/loop11: [64002]:231277388 (/media.img), offset 10000000
        if echo "$line" | grep -q "("; then
            back_file=$(echo "$line" | sed 's/.*(\([^)]*\)).*/\1/')
        # 容器内格式: /dev/loop11: 10000000 /media.img
        else
            back_file=$(echo "$line" | awk '{print $NF}')
        fi
        
        # 检查是否需要清理
        local should_cleanup=false
        
        # 清理绑定到根目录"/"的设备
        if [ "$back_file" = "/" ]; then
            should_cleanup=true
            INFO "发现绑定到根目录的loop设备: $loop_device" >&2
        # 清理绑定到"/xxx.img"格式的设备（包括/config.img和/media.img）
        elif [[ "$back_file" =~ ^/[^/]*\.img$ ]]; then
            should_cleanup=true
            INFO "发现无效绑定的loop设备: $loop_device -> $back_file" >&2
        fi
        
        # 执行清理
        if [ "$should_cleanup" = true ]; then
            INFO "正在清理loop设备: $loop_device" >&2
            
            # 先尝试卸载
            if umount -l "$loop_device" 2>/dev/null; then
                INFO "成功卸载: $loop_device" >&2
            else
                INFO "卸载失败或未挂载: $loop_device" >&2
            fi
            
            # 然后解除绑定
            if losetup -d "$loop_device" 2>/dev/null; then
                # 验证是否真的解除绑定了
                if ! losetup -a | grep -q "^$loop_device:"; then
                    INFO "成功解除绑定: $loop_device" >&2
                    cleaned_count=$((cleaned_count + 1))
                else
                    WARN "解除绑定命令执行成功但设备仍存在: $loop_device" >&2
                fi
            else
                WARN "解除绑定失败: $loop_device" >&2
            fi
        fi
        
    done
    
    if [ $cleaned_count -gt 0 ]; then
        INFO "清理完成，共清理了 $cleaned_count 个无效的loop设备" >&2
    else
        INFO "未发现需要清理的无效loop设备" >&2
    fi
}

if [ -f /media.img ]; then
    chmod 777 /media.img
    
    # 创建挂载点
    if [ ! -d /volume_img ]; then
        mkdir /volume_img
    fi
    
    # 卸载可能存在的挂载
    if grep -qs '/volume_img' /proc/mounts; then
        umount -l /volume_img
    fi
    
    # 清理容器内无效的loop设备
    cleanup_container_loops
    
    # 获取媒体库镜像的loop设备
    if ! get_loop_device "media.img"; then
        echo "media.img loop设备绑定或挂载失败，程序退出！"
        exit 1
    fi   
    echo "媒体库img镜像挂载成功！"
    
    # 清理并重新链接/media
    if [ -d /media ]; then
        if ! rm -rf /media; then
            echo '删除/media失败！使用老G速装版emby请勿将任何目录挂载到容器的/media目录！程序退出！'
            exit 1
        fi
    fi
    ln -sf /volume_img/xiaoya /media
    if [ -L "/volume_img/xiaoya/xiaoya" ]; then
        rm -f "/volume_img/xiaoya/xiaoya"
    fi
    
    # 处理配置镜像（新版双loop模式）
    if [ -f /config.img ]; then
        if [ ! -d /volume_cfg ]; then
            mkdir /volume_cfg
        fi
        
        if grep -qs '/volume_cfg' /proc/mounts; then
            umount -l /volume_cfg
        fi
        
        # 获取配置镜像的loop设备
        if ! get_loop_device "config.img"; then
            echo "config.img loop设备绑定或挂载失败，程序退出！"
            exit 1
        fi
        
        echo "config配置img镜像挂载成功！"
        if sed -i 's/ \/config/ \/volume_cfg\/config/' /etc/services.d/emby-server/run; then
            echo "replace emby's config successed"
        fi
    elif [ -d /volume_img/config ]; then
        # 旧版单loop模式，config在媒体库镜像内
        if sed -i 's/ \/config/ \/volume_img\/config/' /etc/services.d/emby-server/run; then
            echo "replace emby's config successed"
        fi
    fi
else
    echo "media.img镜像不存在，请检查你的emby配置！"
    exit 1
fi
